# Event 기반 아키텍처 설계 및 구현  보고서
---

## 1. 도입 배경

기존 주문 및 결제 처리 흐름은 단일 트랜잭션 내에서 모든 도메인의 로직(주문, 결제, 포인트, 쿠폰, 재고)을 처리하였습니다. 이는 다음과 같은 문제를 초래했습니다:

- 트랜잭션 범위가 너무 넓어지는 구조
- 장애 발생 시 전체 롤백
- 도메인 간 강한 결합
- 확장성과 유지보수성 저하

이를 해결하기 위해 Event 기반 아키텍처를 도입하여 **비동기 처리**, **관심사 분리**, **서비스 간 결합도 감소**를 달성하고자 하였습니다.
---

##  2. 설계 목표

- 핵심 트랜잭션만 먼저 처리하고 후속 로직은 비동기로 처리(핵심, 부가로직)
- 도메인 간 결합도 제거
---

##  3. 아키텍처 구성 개요

###  핵심 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **Event Publisher** | 트랜잭션이 성공한 뒤 후속 이벤트를 발행 |
| **Event Object** | 이벤트 정보 전달용 DTO (ex. OrderCreatedEvent) |
| **Event Listener** | 각 도메인의 후 처리를 담당하는 구독자 |

---

##  4. 주문/결제 이벤트 처리 흐름

### Step-by-step

```text
1. 클라이언트 → 주문 요청 API 호출
2. OrderService.placeOrder() 실행 → 주문 저장 (트랜잭션 내)
3. 주문 저장 성공 시 → OrderCreatedEvent 발행
4. Event Listener → 재고 차감 수행
5. Event Listener → 쿠폰 사용 처리
6. 결제 프로세스 진행 
6. Event Listener → 외부 데이터 플랫폼 전송
```

## 5. 현재 구조의 문제점 
- 트랜잭션 보상의 어려움 
- 순서가 중요한 작업의 경우 오작동 가능

## 6. 향후 개선 방향: 보상 트랜잭션(SAGA) 도입

| 항목       | 보상 트랜잭션 적용 시              |
| -------- | ------------------------- |
| 실패 복원력   | 각 도메인별 실패 시 rollback 가능   |
| 트랜잭션 추적성 | 오케스트레이션/코레오그래피|
| 데이터 일관성  | 논리적 실패에 대해 보상 가능          |

